from ...constants import ORGANIZTION_NAME, COUNTRY_NAME, LOCALITY_NAME, \
COMMON_NAME, CA_VALIDITY_DAYS, CA_ROOT_VALIDITY_DAYS, CA_KEY_SIZE, CERTS_DIR, MAX_MEMORY_CERTS
from dotenv import load_dotenv
import logging
import os
import shutil
from datetime import datetime, timedelta, timezone
import fnmatch
from dataclasses import dataclass
from typing import Tuple, Optional
from collections import OrderedDict

# Cryptography imports
from cryptography import x509
from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID

from ..utils.network_utils import NetworkUtils
from ..structures.cert_bundle import CertBundle
from ..structures.cert_search_status import CertSearchStatus



class CertificateAuthority:
    def __init__(self):
        
        # memory cache
        self._active_certs: OrderedDict[str, CertBundle] = OrderedDict()
        
        # disk index
        self._known_on_disk = self._update_or_load_known_on_disk()
        
        # disk cleanup from expired/old ceritfcates
        self._cleanup_disk()

        # load path from .env 
        ca_dir = os.getenv('ROOT_CA_DIR')

        # ensure storage directories exist
        os.makedirs(ca_dir, exist_ok=True)
        os.makedirs(CERTS_DIR, exist_ok=True)

        self._ca_key_path = os.path.join(ca_dir, "root_ca.key")
        self._ca_cert_path = os.path.join(ca_dir, "root_ca.crt")

        # load or generate the root CA
        self._ca_bundle = self._load_or_generate_root_ca()

    # ==========================================================
    # Public API
    # ==========================================================

    """
    Main entry point. Returns (pem_cert, pem_key, CA_pem_key) for a specific host.
    1. Checks memory cache.
    2. Checks disk cache.
    3. Generates new if missing or expired.
    Returns: 
        - certifcate (bytes): certificate generated and signed by CA, in PEM encoding.
        - private key (bytes): private key assigned for the requested host, 
          generated by CA, in PEM encoding.
        - CA's certifcate (bytes): CA'S certifcate, in PEM encoding.
    """
    def get_certificate_for_host(self, host: str) -> Tuple[bytes, bytes, bytes]:
        res_bundle = None
        
        # Check memory
        memory_status, memory_matching_host, memory_bundle = self._check_memory(host)
        if memory_status == CertSearchStatus.VALID:
            res_bundle = memory_bundle
        elif memory_status == CertSearchStatus.EXPIRED:
            logging.info(f"Certificate for {host} expired. Regenerating...")
            res_bundle = self._issue_host_certificate(memory_matching_host, cert_bundle=memory_bundle, KeepPrivKey=True)
        else:
            # Check disk
            disk_status, disk_matching_host, disk_bundle = self._check_disk(host)
            if disk_status == CertSearchStatus.VALID:
                res_bundle = disk_bundle
            elif disk_status == CertSearchStatus.EXPIRED:
                logging.info(f"Certificate for {host} expired. Regenerating...")
                res_bundle = self._issue_host_certificate(disk_matching_host, cert_bundle=disk_bundle, KeepPrivKey=True)
            else:
                logging.info(f"Certificate for {host} wasn't found. Generating a new one...")
                res_bundle = self._issue_host_certificate(host)
        
        # update memory, disk, and known hosts list on memory.
        self._update_or_add_to_memory(host, res_bundle)
        status, cert_path, key_path = self._update_or_add_to_disk(host, res_bundle)
        if status:
            logging.info(f"Added {host} to memory.")
            self._known_on_disk = self._update_or_load_known_on_disk()
            return cert_path, key_path

        return None, None
        # return res_bundle.pem_cert, res_bundle.pem_key, self._ca_bundle.pem_cert

    # ==========================================================
    #                       Core Logic
    # ==========================================================
    
    """Cleans the disk from invalid certifcates, and certifcates that aren't in use for
       a long period of time (MAX_MEMORY_CERT).
    """
    def _cleanup_disk(self):
        # threshold setting
        threshold = datetime.now(timezone.utc) - timedelta(days=MAX_MEMORY_CERTS)
        for cert_dir in self._known_on_disk:
            dir_path = os.path.join(CERTS_DIR, cert_dir)
            try:
                # cert and priv_key files
                files = os.listdir(dir_path)
                
                # get cert path
                for file in files:
                    if file.endswith(".crt"):
                        cert_path = os.path.join(dir_path, file)
                        # float value (since epoch)
                        cert_modification_time_float = os.path.getmtime(cert_path)
                        break

                # conversion to datetime obj
                cert_modification_time = datetime.fromtimestamp(cert_modification_time_float, tz=timezone.utc)
                # if the threshold is later than cert and key last modfied date
                if cert_modification_time < threshold:
                    logging.info(f"Cleaning up expired/old certificate for {dir_path}")
                    shutil.rmtree(dir_path) # removes directory
            except Exception as e:
                logging.error(f"Failed to delete expired/old certifcate for {dir_path}: {e}", exc_info=True)
                
    """Checks disk cache, in order to find a cert for given host.
        
        Returns: 
            - status (CertSearchStatus) - indacting if the search was successfull or not.
            - hostname (str | None)- the matching hostname, if found.
            - bundle (CertBundle | None
    """
    def _check_disk(self, host: str) -> tuple[CertSearchStatus, str | None, CertBundle | None] | None:
        try:
            for cert_host in self._known_on_disk:
                if self._host_matches_sans(host, cert_host):
                    # directory and files paths
                    host_dir_path = os.path.join(CERTS_DIR, host)
                    cert_path = os.path.join(host_dir_path, f"{host}.crt")
                    priv_key_path = os.path.join(host_dir_path, f"{host}.key")

                    if os.path.exists(cert_path) and os.path.exists(priv_key_path):
                        pem_cert = self._read_from_file(cert_path)
                        pem_key = self._read_from_file(priv_key_path)

                        # create cryptography module objects for CertBundle creation
                        cert = x509.load_pem_x509_certificate(pem_cert)
                        priv_key = serialization.load_pem_private_key(pem_key,password=None)

                        # create CertBundle object
                        bundle = CertBundle(priv_key, cert, pem_key, pem_cert)

                        if not self._is_valid(bundle.certificate):
                            return CertSearchStatus.EXPIRED, cert_host, bundle
                        if bundle is None: # not expected to happen.
                            return CertSearchStatus.NOT_FOUND, cert_host, None
                        else:
                            return CertSearchStatus.VALID, cert_host,  bundle
        
        except Exception as e:
            logging.warning(f"Couldn't check disk properly for certificate for host: {host}. {e}", exc_info=True)
            return CertSearchStatus.NOT_FOUND, None, None
        
        return CertSearchStatus.NOT_FOUND, None, None # Not found

         
    """Checks memory cache, in order to find a cert for given host.
    
    Returns: 
        - status (CertSearchStatus) - indacting if the search was successfull or not.
        - hostname (str | None)- the matching hostname, if found.
        - bundle (CertBundle | None
    """
    def _check_memory(self, host: str) -> tuple[CertSearchStatus, str | None, CertBundle | None]: 
        for cert_host in self._active_certs:
            if self._host_matches_sans(host, cert_host):
                bundle = self._certificates[cert_host]
                if not self._is_valid(bundle.certificate):
                    return CertSearchStatus.EXPIRED, cert_host, bundle
                if bundle is None: # not expected to happen.
                    return CertSearchStatus.NOT_FOUND, cert_host, None
                else:
                    return CertSearchStatus.VALID, cert_host,  bundle
        
        return CertSearchStatus.NOT_FOUND, None,  None 
    
    """
    changed
      - update or odd to disk
      - 
    """

    """update or add a PEM key and PEM cert to disk.
       Returns: True if successfull, False otherwise ."""
    def _update_or_add_to_disk(self, host: str, bundle: CertBundle) -> bool:
        try:
            folder_path = os.path.join(CERTS_DIR, host)
            pem_cert_path = os.path.join(folder_path, f"{host}.crt")
            pem_key_path = os.path.join(folder_path, f"{host}.key")
            if not os.path.exists(folder_path): #folder doesn't exist
                os.mkdir(folder_path)
            self._save_to_file(pem_cert_path, bundle.pem_cert)
            self._save_to_file(pem_key_path, bundle.pem_key)
            logging.info(f"Successfully saved/updated to disk {host}'s Cert and private key.")
            return True, pem_cert_path, pem_key_path
        except Exception as e:
            logging.warning(f"Failed saving/updating to disk {host}'s Cert and private key: {e}", exc_info=True)
            return False, None, None
    

    """update or adds CertBundle object to local memory."""
    def _update_or_add_to_memory(self, host: str, bundle: CertBundle):
        for key, value in self._active_certs.items():
            if key == host: 
                self._active_certs.move_to_end(key)
                if value != bundle:
                    self._active_certs[key] = bundle
                logging.info(self._active_certs)
                return
        
        # wasn't found on dict, add to dict + check if passed max size.
        self._active_certs[host] = bundle
        if len(self._active_certs) > MAX_MEMORY_CERTS:
            self._active_certs.popitem(last=False) # pop the first value - less used

    """loads names for certifcates already made from disk"""
    def _update_or_load_known_on_disk(self) -> list[str]:
        # get sub-dirs names of CERTS_DIR
        try:
            return [dir_name for dir_name in os.listdir(CERTS_DIR)]
        except FileNotFoundError as e:
            logging.warning("Directory {CERTS_DIR} wasn't found.")
            return []
        except Exception as e:
            logging.warning(f"Unexpected error: \
            couldn't load dirs names from {CERTS_DIR} - {e}", exc_info=True)
            return []

    """Loads Root CA from disk or creates it if missing."""
    def _load_or_generate_root_ca(self) -> CertBundle:
        if os.path.exists(self._ca_key_path) and os.path.exists(self._ca_cert_path):
            try:
                logging.info("Loading existing root CA...")
                with open(self._ca_key_path, "rb") as f:
                    pem_ca_key = f.read()
                    priv_key_password = os.getenv("ROOT_CA_PRIVATE_KEY_PASSWORD").encode()
                    priv_key = serialization.load_pem_private_key(pem_ca_key, password=priv_key_password)
                with open(self._ca_cert_path, "rb") as f:
                    pem_ca_cert = f.read()
                    cert = x509.load_pem_x509_certificate(pem_ca_cert)
                
                if not self._is_valid(cert):
                    logging.warning("Root CA is expired. Regenerating...")
                    return self._generate_root_ca()
                
                return CertBundle(
                    private_key=priv_key, certificate=cert,
                    pem_key=pem_ca_key, pem_cert=pem_ca_cert
                )
            except Exception as e:
                logging.error(f"Failed to load CA: {e}. Be aware: Root CA cert would need to be re-installed on client's machine.\
                              Regenerating...", exc_info=True)
        
        return self._generate_root_ca()

    """Generates a Self-Signed Root Certificate. Uses RSA for private, public key and RSA & SHA256 for signatures"""
    def _generate_root_ca(self) -> CertBundle:
        logging.info("Generating new Self-Signed Root CA...")
        
        # generate private key
        private_key = self._generate_private_key()


        # subject is also the issuer since the root ca self-signs it's cert.
        subject = issuer = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, COUNTRY_NAME),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, ORGANIZTION_NAME),
            x509.NameAttribute(NameOID.COMMON_NAME, COMMON_NAME),
        ])

        builder = x509.CertificateBuilder()
        builder = builder.subject_name(subject)
        builder = builder.issuer_name(issuer) 
        builder = builder.public_key(private_key.public_key())
        builder = builder.serial_number(x509.random_serial_number())
        builder = builder.not_valid_before(datetime.now(timezone.utc))
        builder = builder.not_valid_after(datetime.now(timezone.utc) + timedelta(days=CA_ROOT_VALIDITY_DAYS)) 
        
        # CA Constraint: This cert is allowed to sign other certs (=the entity it belongs to is a CA), and unlimited CA's can be signed under it. 
        builder = builder.add_extension(
            x509.BasicConstraints(ca=True, path_length=None), critical=True,)
        
        # self-sign the cert
        cert = builder.sign(private_key=private_key, algorithm=hashes.SHA256())
        
        pem_ca_key = self._key_to_pem(private_key, EncryptKey=True)
        pem_ca_cert = self._cert_to_pem(cert)
        
        # create a CertBundle obj with CA's priv key and pr
        bundle = CertBundle(
            private_key=private_key, certificate=cert,
            pem_key=pem_ca_key, pem_cert= pem_ca_cert
        )

        # Persist CA
        self._save_to_file(self._ca_key_path, bundle.pem_key)
        self._save_to_file(self._ca_cert_path, bundle.pem_cert)
        
        return bundle

    """Generates a certificate for a host, signed by the Root CA."""
    def _issue_host_certificate(self, host: str, *, cert_bundle:CertBundle = None, KeepPrivKey=False) -> CertBundle:
        if KeepPrivKey and cert_bundle:
            private_key = cert_bundle.private_key
        else:
            private_key = self._generate_private_key()
        
        # Host Subject - details are the same as Root ca's certifcate
        subject = x509.Name([
            x509.NameAttribute(NameOID.COUNTRY_NAME, COUNTRY_NAME),
            x509.NameAttribute(NameOID.ORGANIZATION_NAME, ORGANIZTION_NAME),
            x509.NameAttribute(NameOID.COMMON_NAME, host),
        ])

        # Issuer is Root CA
        issuer = self._ca_bundle.certificate.subject

        builder = x509.CertificateBuilder()
        builder = builder.subject_name(subject)
        builder = builder.issuer_name(issuer)
        builder = builder.public_key(private_key.public_key())
        builder = builder.serial_number(x509.random_serial_number())

        # Safety measure - comps aren't always time synced. a delay of couple seconds is possible.
        # in order to prevent cases where the clients refuse certifcates because of delay in time,
        # it is best to set not_valid_before 10 minutes earlier.
        now = datetime.now(timezone.utc) - timedelta(minutes=10) 
        builder = builder.not_valid_before(now)
        builder = builder.not_valid_after(now + timedelta(days=CA_VALIDITY_DAYS))

        # SAN extension - mandatory for modern browsers
        # generate optimizations for SANS
        san_list = self._wildcard_san_optimazition(host)
        builder = builder.add_extension(
            x509.SubjectAlternativeName(
                [x509.DNSName(san_host) for san_host in san_list]
                ),
            critical=False
        )
        # Basic Constraints - Not a CA
        builder = builder.add_extension(
            x509.BasicConstraints(ca=False, path_length=None), critical=True,
        )

        # 4. Sign with the CA's PRIVATE KEY
        certificate = builder.sign(
            private_key=self._ca_bundle.private_key,
            algorithm=hashes.SHA256()
        )

        return CertBundle(
            private_key=private_key, certificate=certificate,
            pem_key=self._key_to_pem(private_key), pem_cert=self._cert_to_pem(certificate)
        )

    def _get_root_ca_cert(self) -> bytes:
        """
        :rtype: ~bytes
        :returns: Root CA's certificate in PEM format.
        """
        return self._ca_bundle.pem_cert
    
    # ==========================================================
    # Helpers
    # ==========================================================
    

    def _wildcard_san_optimazition(self, host: str) -> list[str]:
        san_list = [host] 
        
        # If the host is an IP, don't try to optimize.
        hostname_match = NetworkUtils.get_hostname_from_ip(host)
        if hostname_match is None:
            return san_list
        else:
            # add ip's matching hostname to dictionary
            san_list.append(hostname_match)
            host  = hostname_match
        
        parts = host.split('.')
        
        # Check if it's a standard domain (has at least 1 dot.)
        if len(parts) >= 2:
            # If it starts with www, get the root
            if parts[0] == "www":
                base_domain = ".".join(parts[1:])
                if base_domain not in san_list:
                    san_list.append(base_domain)
            else:
                base_domain = ".".join(parts)

            # Add the wildcard for the base domain (*.google.com)
            # allows the cert to be reused for mail.google.com, drive.google.com...
            wildcard = f"*.{base_domain}"
            if wildcard not in san_list:
                san_list.append(wildcard)

        return san_list
    
    def _host_matches_sans(self, requested_host: str, base_host: str) -> bool:
        """
            Checks if a requested hostname is covered by a base host's certificate scope of SAN's.
            
            This includes exact matches and valid wildcard matches.
            
            Logic:
            - Exact: 'example.com' matches 'example.com'
            - Wildcard: 'www.example.com' matches '*.example.com'
            *Note: Wildcards are only valid for one subdomain level. 
            'mail.il.example.com' doesn't match '*.example.com'

            plan: 
            -keep actual data certifcates on disk.
            -load on start only tyhe names onto a dict in python,
            whenever somenoe request a cert, it does a dict search/disk dearhc/newly created/lo
            - 100 used certifcated are saved on a disk
        """
        requested_parts = requested_host.split(".")
        base_parts= base_host.split(".")

        # if last or previous-to-last parts of the hosts don't match,
        # accordingly. for example, "www.example.com", "www.example.il"
        if requested_parts[-1] != base_parts[-1] or \
                requested_parts[-2] != base_parts[-2]:
            return False
        
        # exact match
        if requested_host == base_host:
            return True
        
        base_host_sans = self._wildcard_san_optimazition(base_host)
        for san_host in base_host_sans:
            if san_host.startswith("*") and san_host.count(".") == requested_host.count("."):
                if fnmatch.fnmatch(requested_host, san_host):
                    return True
            elif san_host == base_host: 
                    # Edge case where base_host starts with www and 
                    # requested_host is a basic host (no subdomains or www)
                    # for example:
                    # -- base_host = www.example.com, requested_host = example.com
                    #    wild_card_optimazition(base_host) returns
                    #    [www.example.com, example.com, *.example.com].
                    #    fnmatch(example.com, *.example.com) returns false, 
                    #    therefore, checking exact mathc is needed for this edge case.
                    return True
        
        return False # No match found

    """Check if a cert is expired."""
    def _is_valid(self, cert: x509.Certificate) -> bool:
        now = datetime.now(timezone.utc)
        # For saftey, - the not_valid_after timestamp is moved back one day in case the certificate 
        # is only seconds or minutes away from becoming invalid
        return cert.not_valid_before_utc <= now < cert.not_valid_after_utc - timedelta(days=1)

    def _generate_private_key(self) -> rsa.RSAPrivateKey:
        return rsa.generate_private_key(public_exponent=65537, key_size=CA_KEY_SIZE)

    def _key_to_pem(self, key: rsa.RSAPrivateKey, EncryptKey=False) -> bytes:
        if EncryptKey:
            # Protect the private key with password
            enc_algorithm = serialization.BestAvailableEncryption(os.getenv("ROOT_CA_PRIVATE_KEY_PASSWORD").encode())
        else:
            enc_algorithm = serialization.NoEncryption()
        return key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm= enc_algorithm
        )

    def _cert_to_pem(self, cert: x509.Certificate) -> bytes:
        return cert.public_bytes(serialization.Encoding.PEM)

    def _save_to_file(self, path: str, data: bytes):
        try:
            with open(path, "wb") as f:
                f.write(data)
        except OSError as e:
            logging.error(f"Failed to save {path}: {e}")

    def _read_from_file(self, path: str) -> bytes:
        try:
            with open(path, "rb") as f:
                raw_data = f.read()
                return raw_data
        except OSError as e:
            logging.error(f"Failed to load {path}: {e}")

if "__main__" == __name__:
    ca = CertificateAuthority()
    logging.info(f"ROOT PK AFTER ENC: {ca._ca_bundle.pem_key}")
    for i in range(30):
        ca.get_certificate_for_host(f"Google{i}.com")
    for cert in ca._active_certs:
        logging.info(f'CertBundle: {cert}')
    logging.info("ACTIVE CERTS (hosts): %s", list(ca._active_certs.keys()))
    logging.info(f"KNOWN ON DISK: {ca._known_on_disk}")